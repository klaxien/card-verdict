syntax = "proto3";

package userprofile.v1;

import "google/protobuf/timestamp.proto";
// 引入 cardverdict 的 CreditFrequency 枚举
import "cards.proto";

// ===================================================================
// 1. 核心消息体 (Core Messages)
// ===================================================================

// (新) 专门用于积分体系的估值
message PointSystemValue {
  // 直接存储每点价值多少美分，例如 1.8 或 0.4。
  // 使用 float (或 double 以获得更高精度) 是最直接、最正确的方式。
  float cents_per_point = 1;

  // 用户对该估值的解释
  string explanation = 2;
}

// (新) 专门用于报销、福利等有固定票面价值的项目
message PerkValue {
  // 用户设定的估值
  oneof value {
    // 价值比例 (e.g., 0.8 代表用户认为此福利只值票面价值的80%)
    float proportion = 1;
    // 绝对价值 (以整数美分为单位, e.g., 用户认为$300的旅行报销对他只值20000 cents)
    int32 value_cents = 2;
  }

  // 用户对该估值的解释 (e.g., "这个航空报销太难用了，我只能用到一半")
  string explanation = 3;
}


// 代表用户自定义的财务调整项
message CustomAdjustment {
  // 由客户端生成的唯一ID (e.g., UUID)，用于编辑或删除此条目。
  string custom_adjustment_id = 1;

  // 用户对此项目的描述
  // e.g., "系统里没有的$50酒店报销", "Retention Offer: $100 statement credit", "海外账户管理费"
  string description = 2;

  // 此项目的发生频率
  cardverdict.v1.CreditFrequency frequency = 3;

  // 此项目的价值，以美分为单位。
  // 使用 sint32 (有符号整数) 来支持正值 (福利) 和负值 (成本)。
  // e.g., 10000 for a $100 benefit, -10000 for a $100 cost.
  sint32 value_cents = 4;

  // 用户的可选备注
  string notes = 5;
}

// (新增) 代表用户针对某一个返现规则的计划支出
message PlannedSpending {
  // 支出的金额，以美分为单位。
  int32 amount_cents = 1;

  // 支出的频率 (每月/每季度/每年)。
  cardverdict.v1.CreditFrequency frequency = 2;

  // (核心设计) 当用户保存此条目时，从 cardverdict.v1.EarningRate 缓存的、
  // 人类可读的描述。这个字段是处理“孤儿数据”的关键。即使原始的 EarningRate
  // 被删除，我们仍然知道这个支出是关于什么的。
  // e.g., "4x on Dining at U.S. Restaurants", "3x on Flights (booked directly)"
  string last_known_rule_description = 3;

  // 当用户保存此条目时，缓存的返现率。
  // 用于在应用启动时检测返现率的变化 (e.g., from 4.0 to 3.0)。
  float last_known_multiplier = 4;

  // 用户的可选备注
  // e.g., "家庭日常买菜", "每年回国机票"
  string notes = 5;
}

message CustomPlannedSpending {
  // 由客户端生成的唯一ID (e.g., UUID)，用于在UI中进行编辑或删除。
  string custom_spending_id = 1;

  // 用户为此自定义类别输入的描述。
  // e.g., "Amex Offer: 20x at Marriott", "特殊返场活动"
  string description = 2;

  // 用户为此自定义类别设置的返现乘数。
  // e.g., 20.0 for 20x
  float multiplier = 3;

  // 用户在此类别下的计划消费金额（以美分为单位）。
  int32 amount_cents = 4;

  // 消费的频率。
  cardverdict.v1.CreditFrequency frequency = 5;

  // 用户的可选备注。
  string notes = 6;
}

// 定义盈亏平衡分析中消费项的计算模式
enum SpendingCalculationMode {
  // 默认值，在代码逻辑中应被视为与 LINEAR 相同，以实现向前兼容。
  MODE_UNSPECIFIED = 0;
  // 消费额随总消费按比例线性增长 (默认行为)
  LINEAR = 1;
  // 消费额是固定的，不随总消费的变化而变化
  FIXED = 2;
}

// 存储与特定卡相关的盈亏平衡分析的用户自定义设置
message BreakevenAnalysisSettings {
  // 是否在计算总回报率时考虑等效年费（所有福利减去年费后的净值）。
  // 这对应UI中的“计算时考虑等效年费”开关。
  // 默认为 false，意味着前端在未设置时应视为不包含，以匹配当前逻辑。
  bool include_equivalent_annual_fee = 1;

  // 映射消费项ID到其计算模式。
  // Key: 可以是 cardverdict.v1.EarningRate.earning_rate_id (对于官方消费类别)
  //      也可以是 CustomPlannedSpending.custom_spending_id (对于自定义消费类别)。
  //      这与前端 UnifiedSpendingField.id 的逻辑完全匹配。
  // Value: 该消费项在图表分析中的计算方式 (线性或固定)。
  map<string, SpendingCalculationMode> spending_calculation_modes = 2;
}

// 存储用户对单张信用卡所有福利和年费的自定义估值
message UserCardValuation {
  // 映射 credit_id 到用户的自定义价值。
  // Key: cardverdict.v1.Credit.credit_id
  map<string, PerkValue> credit_valuations = 1;

  // 映射 benefit_id 到用户的自定义价值。
  // Key: cardverdict.v1.OtherBenefit.benefit_id
  map<string, PerkValue> other_benefit_valuations = 2;

  // 一个列表，包含所有由用户手动添加的、非官方的财务调整项。
  repeated CustomAdjustment custom_adjustments = 3;

  // (核心新增) 映射 EarningRate ID 到用户的计划支出。
  // Key: cardverdict.v1.EarningRate.earning_rate_id
  map<string, PlannedSpending> planned_spending = 4;

  // (核心新增) 一个列表，包含所有由用户手动添加的、非官方的消费类别。
  // 这与 `planned_spending` 完全分离，结构更清晰。
  repeated CustomPlannedSpending custom_planned_spending = 5;

  // 将UI状态与核心估值数据分离，但保持其与特定卡的关联。
  // 如果此字段不存在或为空，前端应使用默认设置。
  BreakevenAnalysisSettings breakeven_analysis_settings = 6;
}

// ===================================================================
// 2. 新的核心结构：估值画像 (NEW: Valuation Profile)
//    这是本次重构的核心，用于封装一套完整的、独立的估值方案。
// ===================================================================

// 代表一套完整的用户估值画像 (e.g., "我的估值", "家人的估值")
message ValuationProfile {
  // Profile 的唯一标识符，由客户端生成 (e.g., UUID)。
  // 将作为 UserAccountData.profiles map 的 key。
  string profile_id = 1;

  // 用户为此 Profile 自定义的显示名称。
  string display_name = 2;

  // Profile 的创建时间戳
  google.protobuf.Timestamp created_at = 3;

  // Profile 的最后更新时间戳
  google.protobuf.Timestamp updated_at = 4;

  // 映射 card_id 到该卡的自定义估值集合。
  // Key: cardverdict.v1.CreditCard.card_id
  map<string, UserCardValuation> card_valuations = 5;

  // 用户对所有“全局”积分体系的自定义估值。
  // Key: cardverdict.v1.PointSystemInfo.system_id
  map<string, PointSystemValue> point_system_valuations = 6;

  // Profile 级别的特定设置。
  ProfileSettings settings = 7;
}

// 为 Profile 级别的设置预留的容器，现在包含筛选和排序设置
message ProfileSettings {
  // --- 筛选设置 ---
  enum FilterMode {
    FILTER_MODE_UNSPECIFIED = 0;  // 默认值，前端可解释为默认行为（如只看个人卡）
    ALL_CARDS = 1;
    PERSONAL_ONLY = 2;
    BUSINESS_ONLY = 3;
    CUSTOM = 4;
    // 注意：没有 'CLEAR_ALL' 模式，因为它是一个瞬时动作，
    // 其结果（一个空的ID列表）应该被作为 'CUSTOM' 模式保存。
  }

  // 保存用户选择的筛选模式，这是决定如何展示卡片的主要依据。
  FilterMode filter_mode = 1;

  // 保存用户自定义选择的卡片ID列表。
  // 这个字段【仅】在 filter_mode 被设置为 CUSTOM 时才应该被读取和使用。
  repeated string custom_selected_card_ids = 2;


  // --- 排序设置 ---
  enum SortOrder {
    SORT_ORDER_UNSPECIFIED = 0;
    NET_WORTH_HIGH_TO_LOW = 1;
    NET_WORTH_LOW_TO_HIGH = 2;
    CREDITS_HIGH_TO_LOW = 3;
    CREDITS_LOW_TO_HIGH = 4;
  }

  // 保存用户选择的排序顺序。
  SortOrder sort_order = 3;
}


// ===================================================================
// 3. 新的顶层消息 (NEW: Top-Level Message)
//    管理用户所有的 Profile 和跨 Profile 的全局设置。
// ===================================================================

// 新的顶层消息，代表一个用户账户的所有相关数据
message UserAccountData {
  // 存储用户拥有的所有估值 Profile。
  // Key: ValuationProfile.profile_id
  map<string, ValuationProfile> profiles = 1;

  // 用户当前激活（或默认查看）的 Profile ID。
  // 这个 ID 必须是 profiles map 中的一个 key。
  string active_profile_id = 2;

  // [可扩展] 跨 Profile 的全局用户偏好设置。
  GlobalSettings global_settings = 3;
}

// 为跨 Profile 的全局设置预留的容器
message GlobalSettings {
  // 可以在此添加未来的设置，例如：
  // enum Theme {
  //   THEME_UNSPECIFIED = 0;
  //   THEME_LIGHT = 1;
  //   THEME_DARK = 2;
  // }
  // Theme theme = 1; // 网站的显示主题
}